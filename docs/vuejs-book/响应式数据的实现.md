---
title: 响应式数据的实现
author: Younglina
date: '2024-02-19'
showAccessNumber: true
categories:
 - 书籍
tags:
 - Vue3
---

<script setup>
  import reactive1 from './01-reactive.vue'
  import reactive2 from './02-reactive.vue'
  import reactive3 from './03-reactive.vue'
  import reactive4 from './04-reactive.vue'
</script>

## 响应式数据的基本实现

<reactive1 />
<<< @/vuejs-book/01-reactive.vue

## 完善的响应系统-01
上一节的实现中，我们硬编码了副作用函数的名字（effect），导致一旦副作用函数的名字不叫 effect，那么这段代码就不能正确地工作了。  
而我们希望的是，哪怕副作用函数是一个匿名函数，也能够被正确地收集到“桶”中。  
为了实现这一点，我们需要提供一个用来注册副作用函数的机制

<reactive2 />
<<< @/vuejs-book/02-reactive.vue

匿名副作用函数内部读取了字段 obj.text 的值，于是匿名副作用函数与字段 obj.text 之间会建立响应联系。  
接着，我们开启了一个定时器，一秒钟后为对象 obj 添加新的 notExist 属性。  
我们知道，在匿名副作用函数内并没有读取 obj.notExist 属性的值，所以理论上，字段 obj.notExist 并没有与副作用建立响应联系，  
因此，定时器内语句的执行不应该触发匿名副作用函数重新执行。  
但如果我们执行上述这段代码就会发现，定时器到时后，匿名副作用函数却重新执行了，这是不正确的。

导致该问题的根本原因是，我们没有在副作用函数与被操作的目标字段之间建立明确的联系。例如当读取属性时，无论读取的是哪一个属性，其实都一样，都会把副作用函数收集到“桶”里；当设置属性时，无论设置的是哪一个属性，也都会把“桶”里的副作用函数取出并执行。

## 完善的响应系统-02
为了解决以上问题，需要修改收集副作用函数的方式。  
- 用 target 来表示一个代理对象所代理的原始对象
- 用 key来表示被操作的字段名
- 用 effectFn 来表示被注册的副作用函数  

那么可以为这三个角色建立如下关系：
```
target
  └─ key  
          └─ effectFn
```

<reactive3 />
<<< @/vuejs-book/03-reactive.vue

从这段代码可以看出构建数据结构的方式，我们分别使用了WeakMap、Map 和 Set：  
- WeakMap 由 target --> Map 构成；  
- Map 由 key --> Set 构成。  
  
其中 WeakMap 的键是原始对象 target，WeakMap 的值是一个Map 实例，  
而 Map 的键是原始对象 target 的 key，Map 的值是一个由副作用函数组成的 Set。

<img src='/Woung/03-reactive.jpg'>

## 分支切换与 cleanup
首先，我们需要明确分支切换的定义，如下面的代码所示：
```javascript
const data = { ok: true, text: 'hello world' }
const obj = new Proxy(data, { /* ... */ })
effect(function effectFn() {
  document.body.innerText = obj.ok ? obj.text : 'not'
})
```
在 effectFn 函数内部存在一个三元表达式，根据字段 obj.ok值的不同会执行不同的代码分支。  
当字段 obj.ok 的值发生变化时，代码执行的分支会跟着变化，这就是所谓的分支切换。  
分支切换可能会产生遗留的副作用函数, 遗留的副作用函数会导致不必要的更新。  
当我们把字段 obj.ok 的值修改为 false，并触发副作用函数重新执行之后，这会触发更新，即副作用函数会重新执行。  
但由于此时 obj.ok 的值为 false，所以不再会读取字段 obj.text 的值。  
换句话说，无论字段 obj.text 的值如何改变，document.body.innerText 的值始终都是字符串 'not'。  
所以最好的结果是，无论 obj.text 的值怎么变，都不需要重新执行副作用函数。  

如果我们能做到每次副作用函数执行前，将其从相关联的依赖集合中移除，那么问题就迎刃而解了。  
要将一个副作用函数从所有与之关联的依赖集合中移除，就需要明确知道哪些依赖集合中包含它，因此我们需要重新设计副作用函数，如下面的代码所示。  
在 effect 内部我们定义了新的 effectFn函数，并为其添加了 effectFn.deps 属性，该属性是一个数组，用来存储所有包含当前副作用函数的依赖集合：
```javascript
let activeEffect
function effect(fn){
  const effectFn = () => {
    activeEffect = effectFn
    fn()
  }
  // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合
  effectFn.deps = []
  effectFn()
}
```
那么 effectFn.deps 数组中的依赖集合是如何收集的呢？其实是在 track 函数中：
```javascript
  function track(target, key) {
    ...
    // 最后将当前激活的副作用函数添加到“桶”里
    deps.add(activeEffect)
    activeEffect.deps.push(deps) // 新增
  }
```
有了这个联系后，我们就可以在每次副作用函数执行时，根据effectFn.deps 获取所有相关联的依赖集合，进而将副作用函数从依赖集合中移除：
```javascript
let activeEffect
function effect(fn){
  const effectFn = () => {
    // 调用 cleanup 函数完成清除工作
    cleanup(effectFn)
    activeEffect = effect
    fn()
  }
  effectFn.deps = []
  effectFn()
}
```

```javascript
function cleanup(effectFn){
  // 遍历 effectFn.deps 数组
  for(let i=0;i<effectFn.deps.length;i++){
    // deps 是依赖集合
    const deps = effectFn.dpes[i]
    // 将 effectFn 从依赖集合中移除
    deps.delete(effectFn)
  }
  // 最后需要重置 effectFn.deps 数组
  effectFn.length = 0
}
```
cleanup 函数接收副作用函数作为参数，遍历副作用函数的effectFn.deps 数组，该数组的每一项都是一个依赖集合，然后将该副作用函数从依赖集合中移除，最后重置 effectFn.deps 数组。

<reactive4 />
